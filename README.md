Tools Used :- {Hardware} Basys3 board by Digilent , A VGA cable , A monitor that supports 640 x 480 resolution ; {Software} Xilinx Vivado Suite 2023.2 ML Edition [you can also use the older versions]

This project aims at displaying an image using the Basys3 board with the VGA [Video Graphics Array] interface. To develop this project, one must understand the basics of VGA interfacing.
The VGA interface uses the three primary colors [Red-Green-Blue]. These three colors are varied by varying the analog voltage levels of the Red-Green-Blue pins. The VGA connector (also called the DB-15 connector) has 15 ports. Of these, ports 1,2 and 3 control the Red-Green-Blue signals while ports 13 and 14 control the Hsync and Vsync signals. The rest of the ports are either GND (ground) connection [ports 5 to 10] or NC (not connected) [ports 4, 11-12, 15]. 
This project is divided into three main modules :- The Clock Generation , The Signal Generation & The Image Display. Linter Check is performed on all the modules and no violations have been reported.

The Clock Generation Module generates a divided clock. VGA interface uses a clock frequency of 25.175 MHz. However, I could not generate the exact 25.175 MHz clock [even with the Clocking Wizard of Vivado]. A lot of published work rounded the clock to 25MHz, and achieved the same results. Since the onboard clock of a Basys3 board generates a frequency of 100MHz, we need to divide this onboard clock by a factor of 4 to get the desired 25MHz clock. A D-flipflop is used to divide a clock to half of it's value, hence we have used two D-flipflops in series connection to divide the onboard clock. The onboard clock is fed into the first D-flipflop, whose output is 50MHz. This output is again fed to a second D-flipflop to further divide the 50MHZ
clock to 25MHz. The correspondig testbench are also provided for a quick verification purpose. This divided clock [now 25MHz] will be used throughout the project for the synchronisation purposes. 

The Signal Generation Module generates all the necessary signals that are required to drive the VGA interface. This includes the horizontal and vertical synchronisation signals, which together determine the active video display area of a screen. A screen(according to the VGA interface) is divided into various sections [more info about this can be found here :- https://digilent.com/reference/learn/programmable-logic/tutorials/vga-display-congroller/start]. To generate the signals, we must first design two counters,the horizontal and vertical counters.The horizontal counter counts from 0-to-799 and resets after counting to the last value. The horizontal counter outputs a tick signal which is activated once the count value reaches to 799. This tick signal acts as a enable to the vertical counter. When the tick signal is high, the vertical counter increases it's value by unity. Togther, these two counters inadvertantly point to the address of each pixel on the screen.
(Vertical Count Value, Horizontal Count Value) together represents the coordinate of a each pixel. The horizontal and vertical synchronization modules work on the value of the counters. When the counters output value corresponding to the display area, the Hsync and Vsync signals go high. The sync signals are important and are used later in the project. The Hsync signal scans the entire screen horizontally. Whenever the front-porch or the back-porch area (count from the horizontal counter) is scanned, the hsync signal goes low. When one complete scan of the hsync signal is completed, the vertical counter signal increases it's value by unity(as already said). One complete scan of the vsync and hsync signal together scan one entire frame (or as we call it, in simple terms, a complete scan of the display area of the screen). With the synchronisation signals now generated, we can finally move over to displaying an image on screen. 

The Image Display is the most trickiest part. To display an image from the Basys3 board, we must first store it in a frame buffer. And for this, we will need to design a frame buffer. A 640 x 480 resolution image has 307200 pixels. If each pixel has a depth of 24 bit (8-bit each for Red-Green-Blue), then there are a total of 16777216 colors, for one pixel. Thus, representing one pixel in full color range using VGA interface would require 16777216 bits. For 307200 pixels, there would be a requirement of 307200 x 16777216 bits, which is a trememdous amount of memory around 644GB. Such a huge memory space is not available on a Basys3 board. So, in order to avoid this issue, we have represented each of the Red-Green-Blue value using 2 bits each. That is, 2bits for red, 2bits for green, 2bits for blue. This reduces down our memory to 225 Kb, which is well within the BRAM range of the Basys3 board. A BRAM [Block Random Access Memory] , is a memory on FPGA board/chip that is used to store a large amount of data, like image pixels, mathematical coefficients etc. Basys3 board has 1.8Mb of BRAM, which is enough to support our project.
We have generated a frame buffer of 307200 cells, with each cell being 6bit in depth. In general, if nothing was stored in the frame buffer, we would have most likely got either a black screen, or noise (like Impulse Noise) on the screen. But in this case, we have loaded an image onto the frame buffer. Before loading the image, we have first converted it into 640x480 resolution, then changed it to black-white color and finally converted it to a mem file. Conversion to a mem file is important since verilog reads the mem file and not an actual image with '.png / .jpg' extension. This conversion can be made using a simple python script, using the pillows library. 
Once converter, this image is loaded onto the framebuffer using the "$readmemh" function. When the image is loaded,we use a pixel pointer to read the contents of the frame buffer(which is now the image mem file) onto the screen.The pixel pointer works based on the enable signal and the horizontal-vertical synchronisation signals. It starts with the first cell of the frame buffer and increaments its value by unity with each clock pulse. When the synchronisation signals are Low, the pixel pointer holds its current value (since the low synchronisation signals indicate the non display region of the screen). The output of the pixel pointer is the values of the frame buffer, which we had loaded earlier,and these values are fed to the RGB channel(declared on the top module) for proper display on the screen. 